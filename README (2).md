#Анализ работы интеллектуального указателя auto_ptr, а также его отличия от unique_ptr.
**Концепция создания auto_ptr заключалась в том, чтобы производить отчистку программы после её завершения от обьектов, выделенных пло динамическому принципу
с помощью опереции new, тоесть обьектов которые размещенны в разделе памяти "куча".Частично эта задача была реализованна, но для полноценного использования
её полная реализация не прошла стадию завершения, в виду отсутствия, необходимых инструменртов.Борьба за реализацию auto_ptr велась вплоть до С++17 стандартов, 
после выпуска которых auto_ptr был снят с пользования(надо добавить что, запрещён к использованию директивой, но не компилятором).На заменну auto_ptr, пришел 
взятый из библиотеки Boost, unique_ptr и shared_ptr, которые в свою очередь, вошли в стандартную библиотеку С++.
Общие характеристики auto_ptr следующие(список ключевых компонентов класса auto_ptr) :
*1.конструктор преобразования с модификатором explicit.
*2.три конструктора с один параметром для различных шаблонных,классов, которые сродержит в себе класс  auto_ptr.
*3.деструктор.
*4.операторы(разыменования для динамически выделенных обьектов и присваивания)
*5. использование исключений, методов get()(для возврата сохранённого указателя), reset()(для уничтожения обьекта с которым работает auto_ptr) 
releasу()(для освобождения владения сохранённым указателем).
 Ключевые проблемы которые хранит в себе auto_ptr, следующие.
При копировании обьекта auto_ptr, другим обьектом auto_ptr, возникает проблема двоиственного владения одним обьектом, в результате которого могут возникнуть
непредсказуемые последствия которые приводят к сбою программы( при моей реализации auto_ptr,при попытке копирования, компилятор выдавал исключения, которое 
препятствовало завершению программы). Эта проблема заключается в отсутствии метода подсчёта (счётчика), который содержит в себе например shared_ptr, способный
подсчитывать количество владельцев, указателей ссылающихся на обьект shared_ptr, при котором деструктор способен удалить все оставив лишь одного владельца.
Другие проблемы заключающиеся в auto_ptr, это попытка реализации симантики перемищения, с использованием оператора копировани, метод которого, в данном случае 
выходит очень трудозатратным занимающим относительно много времени. auto_ptr также не желательно использовать для контейнеров так как происходит поэлементное
 копирование элементов(в данном случае более оптимальным является метод move симантики).
При использовании же unique_ptr, происходит более корректная обработка исключений, где при множественном владении, к примеру компилятор, в целом, выдаёт ошибку
компиляции предотвращая возможность непредсказуеммых последствий работы программы.Помогает этому использование метод noexcept.А также удалён оператор 
присваивания, который помагает избежать множественным владением обьекта.**

 